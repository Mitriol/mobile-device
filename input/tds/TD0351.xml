<?xml version="1.0" encoding="utf-8"?>
<technical-decisions xmlns:htm="http://www.w3.org/1999/xhtml"
                     xmlns="https://niap-ccevs.org/cc/v1">
    <bunch>
        <!--
         Replace entire f-elements from the base PP and update - f-components?
         Non-SFR changes made using XPATH expressions
        -->
        <applies-to max-inclusive="3.1" name="Mobile Device Fundamentals"/>

        <decision id='0351'>
            <notes>Additional methods for DEK formation</notes>
            <change xpath=".//f-element[@id='fcs_ckm_ext.2.1']" mode="replace">
                <f-element id="fcs_ckm_ext.2.1">
                    <title>All<abbr linkend="DEK"/>s shall be
                        <selectables>
                            <selectable>randomly generated</selectable>
                            <selectable>from the combination of a randomly generated DEK with another DEK or salt in a
                                way that preserves the effective entropy of each factor by
                                <selectables>
                                    <selectable>using an XOR operation</selectable>
                                    <selectable>concatenating the keys and using a KDF (as described in SP 800-108)
                                    </selectable>
                                    <selectable>concatenating the keys and using a KDF (as described in SP 800-56C)
                                    </selectable>
                                </selectables>
                            </selectable>
                        </selectables>
                        with entropy corresponding to the security strength of AES key sizes of
                        <selectables>
                            <selectable>128</selectable>
                            <selectable>256</selectable>
                        </selectables>
                        bits.
                    </title>
                    <note role="application">
                        The intent of this requirement is to ensure that the DEK cannot be recovered with less work than
                        a full exhaust of the key space for AES. The key generation capability of the TOE uses a RBG
                        implemented on the TOE device (FCS_RBG_EXT.1). Either 128-bit or 256-bit (or both) are allowed;
                        the ST author makes the selection appropriate for the device. A DEK is used in addition to the
                        KEK so that authentication factors can be changed without having to re-encrypt all of the user
                        data on the device.
                        <htm:br></htm:br>
                        <htm:br></htm:br>
                        The ST author selects all applicable DEK generation types implemented by the TOE.
                        <htm:br></htm:br>
                        <htm:br></htm:br>
                        If combined, the ST author shall describe which method of combination is used in order to
                        justify that the effective entropy of each factor is preserved, and the ST author shall describe
                        that each combined value was originally generated from an Approved DRBG described in
                        FCS_RBG_EXT.1.
                        <htm:br/>
                        <htm:br/>
                        The documentation of the product's encryption key management should be detailed enough that,
                        after reading, the evaluator will thoroughly understand the product's key management and how it
                        meets the requirements to ensure the keys are adequately protected. This documentation should
                        include an essay and diagram(s). This documentation is not required to be part of the TSS - it
                        can be submitted as a separate document and marked as developer proprietary.
                        <htm:br/>
                        <htm:br/>
                        SP 800-56C specifies a two-step key derivation procedure that employs an
                        extraction-then-expansion technique for deriving keying material from a shared secret generated
                        during a key establishment scheme. The Randomness Extraction step as described in Section 5 of
                        SP 800-56C is followed by Key Expansion using the key derivation functions defined in SP 800-108
                        (as described in Section 6 of SP 800-56C).
                    </note>
                    <aactivity>
                        <htm:br/>
                        TSS
                        <htm:br/>
                        The evaluator shall examine the key hierarchy section of the
                        <abbr linkend="TSS"/>
                        to ensure that the formation of all<abbr linkend="DEK"/>s is described and that the key sizes
                        match that described by the
                        <abbr linkend="ST"/>
                        author. The evaluator shall examine the key hierarchy section of the
                        <abbr linkend="TSS"/>
                        to ensure that each (
                        <abbr linkend="DEK"/>
                        is generated or combined from keys of equal or greater security strength using one of the
                        selected methods.
                        <htm:br/>
                        <htm:ul>
                            <htm:li>The evaluator shall review the
                                <abbr linkend="TSS"/>
                                to verify that it contains a description of the PBKDF use to derive<abbr linkend="KEK"/>
                                s. This description must include the size and storage location of salts. This activity
                                may be performed in combination with that for<linkref linkend="FCS_COP.1(5)"/>.
                            </htm:li>
                            <htm:li>If the symmetric
                                <abbr linkend="DEK"/>
                                is generated by an RBG, the evaluator shall review the
                                <abbr linkend="TSS"/>
                                to determine that it describes how the functionality described by
                                <linkref linkend="FCS_RBG_EXT.1"/>
                                is invoked. The evaluator uses the description of the RBG functionality in
                                <linkref linkend="FCS_RBG_EXT.1"/>
                                or documentation available for the operational environment to determine that the key
                                size being requested is greater than or equal to the key size and mode to be used for
                                the encryption/decryption of the data.
                            </htm:li>
                            <htm:li>If the
                                <abbr linkend="DEK"/>
                                is formed from a combination, the evaluator shall verify that the
                                <abbr linkend="TSS"/>
                                describes the method of combination and that this method is either an XOR, or a KDF.
                            </htm:li>
                        </htm:ul>
                        <htm:br/>
                        If “concatenating the keys and using a KDF (as described in (SP 800-56C)” is selected, the
                        evaluator shall ensure the TSS includes a description of the randomness extraction step.
                        <htm:ul>
                            <htm:li>The description must include how an approved untruncated MAC function is being used
                                for the randomness extraction step and the evaluator must verify the TSS describes that
                                the output length (in bits) of the MAC function is at least as large as the targeted
                                security strength (in bits) of the parameter set employed by the key establishment
                                scheme (see Tables 1-3 of SP 800-56C).
                            </htm:li>
                            <htm:li>The description must include how the MAC function being used for the randomness
                                extraction step is related to the PRF used in the key expansion and verify the TSS
                                description includes the correct MAC function:
                            </htm:li>
                            <htm:ul>
                                <htm:li>If an HMAC-hash is used in the randomness extraction step, then the same
                                    HMAC-hash (with the same hash function hash) is used as the PRF in the key expansion
                                    step.
                                </htm:li>
                                <htm:li>If an AES-CMAC (with key length 128, 192, or 256 bits) is used in the randomness
                                    extraction step, then AES-CMAC with a 128-bit key is used as the PRF in the key
                                    expansion step.
                                </htm:li>
                            </htm:ul>
                            <htm:li>The description must include the lengths of the salt values being used in the
                                randomness extraction step and the evaluator shall verify the TSS description includes
                                correct salt lengths:
                            </htm:li>
                            <htm:ul>
                                <htm:li>If an HMAC-hash is being used as the MAC, the salt length can be any value up to
                                    the maximum bit length permitted for input to the hash function hash.
                                </htm:li>
                                <htm:li>If an AES-CMAC is being used as the MAC, the salt length shall be the same
                                    length as the AES key (i.e. 128, 192, or 256 bits).
                                </htm:li>
                            </htm:ul>
                            <htm:br/>
                            (conditional) If a KDF is used, the evaluator shall ensure that the TSS includes a
                            description of the key derivation function and shall verify the key derivation uses an
                            approved derivation mode and key expansion algorithm according to SP 800-108 or SP 800-56C.
                        </htm:ul>
                        <htm:br/>
                        Guidance
                        <htm:br/>
                        The evaluator uses the description of the RBG functionality in FCS_RBG_EXT.1 or documentation
                        available for the operational environment to determine that the key size being generated or
                        combined is identical to the key size and mode to be used for the encryption/decryption of the
                        data.
                        <htm:br/>
                        <htm:br/>
                        Tests
                        <htm:br/>
                        If a KDF is used, the evaluator shall perform one or more of the following tests to verify the
                        correctness of the key derivation function, depending on the mode(s) that are supported.
                        <ctr-ref ref-id="KDF"/>
                        maps the data fields to the notations used in SP 800-108 and SP 800-56C.
                        <htm:br/>
                        <htm:br/>
                        <htm:b>
                            <ctr pre="Table " id="KDF" ctr-type="table">: Notations used in SP 800-108 and SP 800-56C
                            </ctr>
                        </htm:b>
                        <htm:br/>
                        <htm:table>
                            <htm:tr class="header">
                                <htm:td>Data Fields</htm:td>
                                <htm:td colspan="2">Notations</htm:td>
                            </htm:tr>
                            <htm:tr class="header">
                                <htm:td></htm:td>
                                <htm:td>SP 800-108</htm:td>
                                <htm:td>SP 800-56C</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Pseudorandom function</htm:td>
                                <htm:td>PRF</htm:td>
                                <htm:td>PRF</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Counter length</htm:td>
                                <htm:td>r</htm:td>
                                <htm:td>r</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Length of output of PRF</htm:td>
                                <htm:td>h</htm:td>
                                <htm:td>h</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Length of derived keying material</htm:td>
                                <htm:td>L</htm:td>
                                <htm:td>L</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Length of input values</htm:td>
                                <htm:td>I_length</htm:td>
                                <htm:td>I_length</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Pseudorandom input values I</htm:td>
                                <htm:td>K<htm:sub>1</htm:sub> (key derivation key)
                                </htm:td>
                                <htm:td>Z (shared secret)</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Pseudorandom salt values</htm:td>
                                <htm:td>n/a</htm:td>
                                <htm:td>s</htm:td>
                            </htm:tr>
                            <htm:tr>
                                <htm:td>Randomness extraction MAC</htm:td>
                                <htm:td>n/a</htm:td>
                                <htm:td>MAC</htm:td>
                            </htm:tr>


                        </htm:table>

                        <htm:br/>
                        <htm:br/>
                        <htm:b>Counter Mode Tests:</htm:b>
                        <htm:br/>
                        <htm:br/>
                        The evaluator shall determine the following characteristics of the key derivation function:
                        <htm:ul>
                            <htm:li>One or more pseudorandom functions that are supported by the implementation (PRF).
                            </htm:li>
                            <htm:li>One or more of the values {8, 16, 24, 32} that equal the length of the binary
                                representation of the counter (r).
                            </htm:li>
                            <htm:li>The length (in bits) of the output of the PRF (h).</htm:li>
                            <htm:li>Minimum and maximum values for the length (in bits) of the derived keying material
                                (L). These values can be equal if only one value of L is supported. These must be evenly
                                divisible by h.
                            </htm:li>
                            <htm:li>Up to two values of L that are NOT evenly divisible by h.</htm:li>
                            <htm:li>Location of the counter relative to fixed input data: before, after, or in the
                                middle.
                                <htm:ul>
                                    <htm:li>Counter before fixed input data: fixed input data string length (in bytes),
                                        fixed input data string value.
                                    </htm:li>
                                    <htm:li>Counter after fixed input data: fixed input data string length (in bytes),
                                        fixed input data string value.
                                    </htm:li>
                                    <htm:li>Counter in the middle of fixed input data: length of data before counter (in
                                        bytes), length of data after counter (in bytes), value of string input before
                                        counter, value of string input after counter.
                                    </htm:li>
                                </htm:ul>
                            </htm:li>
                            <htm:li>The length (I_length) of the input values I.</htm:li>

                        </htm:ul>
                        <htm:br/>
                        For each supported combination of I_length, MAC, salt, PRF, counter location, value of r, and
                        value of L, the evaluator shall generate 10 test vectors that include pseudorandom input values
                        I, and pseudorandom salt values. If there is only one value of L that is evenly divisible by h,
                        the evaluator shall generate 20 test vectors for it. For each test vector, the evaluator shall
                        supply this data to the TOE in order to produce the keying material output.
                        <htm:br/>
                        <htm:br/>

                        The results from each test may either be obtained by the evaluator directly or by supplying the
                        inputs to the implementer and receiving the results in response. To determine correctness, the
                        evaluator shall compare the resulting values to those obtained by submitting the same inputs to
                        a known good implementation.
                        <htm:br/>
                        <htm:br/>

                        <htm:b>Feedback Mode Tests:</htm:b>
                        <htm:br/>
                        The evaluator shall determine the following characteristics of the key derivation function:
                        <htm:br/>
                        <htm:ul>
                            <htm:li>One or more pseudorandom functions that are supported by the implementation (PRF).
                            </htm:li>
                            <htm:li>The length (in bits) of the output of the PRF (h).</htm:li>
                            <htm:li>Minimum and maximum values for the length (in bits) of the derived keying material
                                (L). These values can be equal if only one value of L is supported. These must be evenly
                                divisible by h.
                            </htm:li>
                            <htm:li>Up to two values of L that are NOT evenly divisible by h.</htm:li>
                            <htm:li>Whether or not zero-length IVs are supported.</htm:li>
                            <htm:li>Whether or not a counter is used, and if so:
                                <htm:ul>
                                    <htm:li>One or more of the values {8, 16, 24, 32} that equal the length of the
                                        binary representation of the counter (r).
                                    </htm:li>
                                    <htm:li>Location of the counter relative to fixed input data: before, after, or in
                                        the middle.
                                    </htm:li>
                                    <htm:ul>
                                        <htm:li>Counter before fixed input data: fixed input data string length (in
                                            bytes), fixed input data string value.
                                        </htm:li>
                                        <htm:li>Counter after fixed input data: fixed input data string length (in
                                            bytes), fixed input data string value.
                                        </htm:li>
                                        <htm:li>Counter in the middle of fixed input data: length of data before counter
                                            (in bytes), length of data after counter (in bytes), value of string input
                                            before counter, value of string input after counter.
                                        </htm:li>
                                    </htm:ul>
                                </htm:ul>
                            </htm:li>
                            <htm:li>The length (I_length) of the input values I.</htm:li>
                        </htm:ul>
                        <htm:br/>
                        For each supported combination of I_length, MAC, salt, PRF, counter location (if a counter is
                        used), value of r (if a counter is used), and value of L, the evaluator shall generate 10 test
                        vectors that include pseudorandom input values I and pseudorandom salt values. If the KDF
                        supports zero-length IVs, five of these test vectors will be accompanied by pseudorandom IVs and
                        the other five will use zero-length IVs. If zero-length IVs are not supported, each test vector
                        will be accompanied by an pseudorandom IV. If there is only one value of L that is evenly
                        divisible by h, the evaluator shall generate 20 test vectors for it.
                        <htm:br/>
                        <htm:br/>
                        For each test vector, the evaluator shall supply this data to the
                        <abbr linkend="TOE"/>
                        in order to produce the keying material output. The results from each test may either be
                        obtained by the evaluator directly or by supplying the inputs to the implementer and receiving
                        the results in response. To determine correctness, the evaluator shall compare the resulting
                        values to those obtained by submitting the same inputs to a known good implementation.
                        <htm:br/>
                        <htm:br/>

                        <htm:b>Double Pipeline Iteration Mode Tests:</htm:b>
                        <htm:br/>
                        <htm:br/>
                        The evaluator shall determine the following characteristics of the key derivation function:
                        <htm:br/>
                        <htm:br/>
                        <htm:ul>
                            <htm:li>One or more pseudorandom functions that are supported by the implementation (PRF).
                            </htm:li>
                            <htm:li>The length (in bits) of the output of the PRF (h).</htm:li>
                            <htm:li>Minimum and maximum values for the length (in bits) of the derived keying material
                                (L). These values can be equal if only one value of L is supported. These must be evenly
                                divisible by h.
                            </htm:li>
                            <htm:li>Up to two values of L that are NOT evenly divisible by h.</htm:li>
                            <htm:li>Whether or not a counter is used, and if so:
                                <htm:ul>
                                    <htm:li>One or more of the values {8, 16, 24, 32} that equal the length of the
                                        binary representation of the counter (r).
                                    </htm:li>
                                    <htm:li>Location of the counter relative to fixed input data: before, after, or in
                                        the middle.
                                        <htm:ul>
                                            <htm:li>Counter before fixed input data: fixed input data string length (in
                                                bytes), fixed input data string value.
                                            </htm:li>
                                            <htm:li>Counter after fixed input data: fixed input data string length (in
                                                bytes), fixed input data string value.
                                            </htm:li>
                                            <htm:li>Counter in the middle of fixed input data: length of data before
                                                counter (in bytes), length of data after counter (in bytes), value of
                                                string input before counter, value of string input after counter.
                                            </htm:li>
                                        </htm:ul>
                                    </htm:li>
                                </htm:ul>
                            </htm:li>
                            <htm:li>The length (I_length) of the input values I.</htm:li>
                        </htm:ul>
                        <htm:br/>
                        For each supported combination of I_length, MAC, salt, PRF, counter location (if a counter is
                        used), value of r (if a counter is used), and value of L, the evaluator shall generate 10 test
                        vectors that include pseudorandom input values I, and pseudorandom salt values. If there is only
                        one value of L that is evenly divisible by h, the evaluator shall generate 20 test vectors for
                        it.
                        <htm:br/>
                        <htm:br/>
                        For each test vector, the evaluator shall supply this data to the
                        <abbr linkend="TOE"/>
                        in order to produce the keying material output. The results from each test may either be
                        obtained by the evaluator directly or by supplying the inputs to the implementer and receiving
                        the results in response. To determine correctness, the evaluator shall compare the resulting
                        values to those obtained by submitting the same inputs to a known good implementation.
                    </aactivity>
                </f-element>
            </change>
        </decision>
    </bunch>
</technical-decisions>
